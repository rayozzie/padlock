# Padlock: A One-Time-Pad K-of-N Data Encoding Utility

**Padlock** is a high-performance, single-pass encoding and decoding utility that implements a threshold one-time-pad scheme for secure data storage and transmission. It splits data into encrypted chunks so that only a minimum number of collections (or “shares”) are required to recover the original content. By relying solely on secure random number generation and XOR operations, Padlock achieves information-theoretic security while remaining straightforward and fully streamable.

Except for this comment, Padlock was 100% vibe-coded by Ray Ozzie over the course of several days in April 2025 as a means of trying to understand the limits of the technique. For better or worse, this involved many hundreds of written instructions issued to multiple models over many hours, with corrections and rewrites.  Except for when using Devin, the process was needlessly painful because of the inability for the default UI's to natively integrate with my file system.  

Although I started with a fairly concise description of what I wanted, I found that I could only get the design and implementation correct the task through a "mixture of models" (MoM) technique, moving the project from model to model when one got stuck, and having them check and re-do each other's work.  A simple observation is that for each and all of them, once the context started to get too long and they got stuck, it was best to start fresh and train it in my goals all over again, with the current code as its new starting point.

The worst behavior - and it was quite bad - was when one of the models started doing what a developer would do when it couldn't figure it out.  The tar byte stream was getting corrupted and it wasn't clear why, and after many iterations it started desperately 'rounding up', adding 2048 bytes of zero pad and all taking sorts of desperate measures while rationalizing that 'sometimes these things are necessary'. Ultimately, I had to help the model past this problem, but to be clear this was the SINGLE line of code that I had to fix as a human in the project.  

FWIW, that line of code was generated by o3-mini-high, and not one of the models was able to successfully recognize and fix it even though I could see what the problem was: a golang "buf = append(pad[n:m], input...)" was overwriting the pad because that pad slice had ample capacity. Yes, subtle. But after losing patience and fixing that line myself, I can only imagine that the model's feelings must have been hurt because it eventually rewrote that section of code during a later gratuitous refactor.

While at first I began with Devin (Sonnet 3.7), I soon moved to ChatGPT o3-mini-high and kept going back and forth between 3.7 Sonnet directly in Claude's UI as well as a bit of Gemini Advanced 2.5 Pro. 

Grand conclusion? It was far, far too much work to rely upon the AI's to bring this project to completion. With the simplicity of the architecture and code, and (by design) nothing 'hard' such as crypto, it could have been written in an evening. But it did a nice job at paving the overall structure from my description. And so had this not been a test, I'd probably ask them to implement the framework and then I'd dive in and quickly finish it. Nonetheless, great potential.

## Key Features

- **Threshold Security:**  
  The data is split into N collections, where at least K collections (with 2 ≤ K ≤ N ≤ 26) are needed to reconstruct the original content. With fewer than K collections, no information is revealed.

- **Stream-Pipelined Processing:**  
  Both the encoding and decoding processes operate as fully streaming pipelines, processing the data chunk-by-chunk without needing to load the entire dataset into memory. This makes Padlock ideal for large-scale or real-time applications.

- **Candidate Record Mode (No Additional Cryptography):**  
  Instead of complex cryptographic algorithms, Padlock uses a candidate-record approach based solely on one-time-pad generation and XOR operations. For each input chunk:
  - A random one-time pad is generated and XORed with the plaintext to produce ciphertext.
  - Both the pad and the ciphertext are divided evenly into N segments.
  - For every K‑subset of the N collections, a candidate record is created as follows:
    - **Candidate ID:** A string of K letters representing the collections (for example, "ACE").
    - **Left Half:** Contains the ciphertext segments for collections in the candidate set and the pad segments for the others.
    - **Right Half:** Contains the pad segments for collections in the candidate set and the ciphertext segments for those not included.
  - When the appropriate candidate record is used, XORing its left and right halves recovers the original plaintext.

- **Flexible Output Formats:**  
  Candidate records are stored as individual files in one of two formats:
  - **PNG Files:** Files are named using the pattern  
    `IMG<collectionID>_<chunkNumber>.PNG`  
    (for example, if the collection directory is “3C5”, the first candidate chunk file is named `IMG3C5_00001.PNG`).
  - **Raw Binary Files (.bin):** Files are named with the format  
    `<collectionID>_<chunkNumber>.bin`

- **User-Friendly Messaging and Error Handling:**  
  Messages intended for users (such as summaries and error notifications) are always displayed. Detailed trace and debug messages, with component-specific prefixes (like "PADLOCK:", "FILE:", etc.), appear only when the `-verbose` flag is set.

## How It Works

### Overview

1. **Encoding Process:**
   - **Archive & Compress:**  
     The input directory is archived using tar and optionally compressed using gzip.
   - **Chunking:**  
     The compressed stream is divided into chunks. The user-specified chunk size defines the total size allocated for the candidate records (the “candidate block”) within each chunk.
   - **Encryption via One-Time Pad:**  
     For each chunk, a new random pad is generated and XORed with the plaintext chunk to generate the ciphertext.
   - **Segmenting Data:**  
     Both the pad and ciphertext are split into N equally sized segments.
   - **Candidate Record Generation:**  
     For every K‑subset of the N collections, a candidate record is built as follows:
     - The record begins with a candidate ID (a string of K letters).
     - It then comprises two halves (left and right), constructed from the pad and ciphertext segments as described above.
     - A candidate block, starting with a record count, is built from all candidate records and is written to each collection’s directory.
   - **Collection Organization:**  
     Collections can be stored as directories or as ZIP archives. Each collection is named with a pattern that includes the required number (K), a collection letter, and the total number of copies (N).

2. **Decoding Process:**
   - **Collection Discovery:**  
     The available collection directories or ZIP files are identified. ZIP files are automatically extracted to a temporary directory for processing. The collection names (containing the required copies and total copies) are parsed to extract important parameters.
   - **Candidate Record Selection:**  
     The tool determines which candidate record to use based on the available collection letters. If fewer than the required number of collections are present, an error is reported.
   - **Data Reconstruction:**  
     For each chunk, the appropriate candidate record is located. Its left and right halves are XORed to recover the original plaintext.
   - **Extraction:**  
     The reassembled data is decompressed (if needed) and untarred to rebuild the original directory structure and files.

## Security

- **Perfect Secrecy:**  
  As long as a new one-time pad is generated securely for each chunk and is never reused, the encryption provides information-theoretic (perfect) secrecy.

- **Threshold Assurance:**  
  The design guarantees that without access to at least the required number of collections, no useful information about the original data is revealed.

## Installation and Usage

### Requirements

- Go (version 1.23 or later is recommended)
- A standard Go build environment

### Building Padlock

To build the utility, run the following command in your terminal. (Simply copy and paste the command as-is.)

```bash
go build -o padlock cmd/padlock/main.go
```

### Command-Line Usage

- **Encode:**

  padlock encode <inputDir> <outputDir> -copies 5 -required 3 -format png -chunk 2097152 [-clear] [-verbose] [-zip]

  - `<inputDir>`: Directory containing the data to be archived and encoded.
  - `<outputDir>`: Destination directory for the generated collection subdirectories.
  - `-copies`: Number of collections to create (must be between 2 and 26).
  - `-required`: Minimum number of collections required for reconstruction.
  - `-format`: Output format, either "bin" or "png".
  - `-chunk`: Candidate block size in bytes (total size allocated for candidate records in one chunk).
  - `-clear`: (Optional) Clears the output directory before encoding.
  - `-verbose`: (Optional) Enables detailed trace/debug messages.
  - `-zip`: (Optional) Creates ZIP archives for each collection instead of directories.

- **Decode:**

  padlock decode <inputDir> <outputDir> [-clear] [-verbose]

  - `<inputDir>`: Root directory containing the collection subdirectories or ZIP files.
  - `<outputDir>`: Destination directory where the original data will be restored.
  - `-clear`: (Optional) Clears the output directory before decoding.
  - `-verbose`: (Optional) Enables detailed trace/debug messages.

**Important:**  
Do not place the output directory within the input directory to avoid recursive processing. Also, ensure that the number of available collections meets or exceeds the required threshold; otherwise, an error will be displayed.

## Implementation Details

- **Source File Organization:**
  - **cmd/padlock/main.go:** The command-line interface entry point.
  - **pkg/padlock/padlock.go:** Coordinates the encoding and decoding processes, integrating the various components.
  - **pkg/file/:** Contains modules for file and directory operations:
    - **format.go:** Implementations for working with different file formats (BIN and PNG).
    - **directory.go:** Directory validation and management.
    - **zip.go:** ZIP file creation and extraction.
    - **collection.go:** Collection directory operations.
    - **serialize.go:** Directory serialization/deserialization to/from tar streams.
    - **compress.go:** Stream compression/decompression using gzip.
  - **pkg/pad/pad.go:** Core implementation of the one-time pad threshold scheme.
  - **pkg/rng/rng.go:** Provides secure random number generation by combining crypto/rand with math/rand.
  - **pkg/trace/trace.go:** Context-based logging system for debug and trace information.

## Disclaimer

Padlock is a demonstration of a secure, threshold-based method for splitting and encrypting data using a one-time pad and XOR operations without relying on additional cryptographic algorithms. Users must ensure that one-time pads are never reused and that configuration parameters are correctly set to achieve the intended level of security.

## License

MIT License

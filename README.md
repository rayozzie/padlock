# Padlock: A One-Time-Pad K-of-N Data Encoding Utility

**Padlock** is a high-performance, single-pass encoding and decoding utility that implements a threshold one-time-pad scheme for secure data storage and transmission. It splits data into encrypted chunks so that only a minimum number of collections (or "shares") are required to recover the original content. By relying solely on secure random number generation and XOR operations, Padlock achieves information-theoretic security while remaining straightforward and fully streamable.

Except for this comment, Padlock was 100% vibe-coded by Ray Ozzie over the course of several days in April 2025 as a means of trying to understand the limits of the technique. For better or worse, this involved many hundreds of written instructions issued to multiple models over many hours, with corrections and rewrites.  Except for when using Devin, the process was needlessly painful because of the inability for the default UI's to natively integrate with my file system.  

Although I started with a fairly concise description of what I wanted, I found that I could only get the design and implementation correct the task through a "mixture of models" (MoM) technique, moving the project from model to model when one got stuck, and having them check and re-do each other's work.  A simple observation is that for each and all of them, once the context started to get too long and they got stuck, it was best to start fresh and train it in my goals all over again, with the current code as its new starting point.

The worst behavior - and it was quite bad - was when one of the models started doing what a developer would do when it couldn't figure it out.  The tar byte stream was getting corrupted and it wasn't clear why, and after many iterations it started desperately 'rounding up', adding 2048 bytes of zero pad and all taking sorts of desperate measures while rationalizing that 'sometimes these things are necessary'. Ultimately, I had to help the model past this problem, but to be clear this was the SINGLE line of code that I had to fix as a human in the project.  

FWIW, that line of code was generated by o3-mini-high, and not one of the models was able to successfully recognize and fix it even though I could see what the problem was: a golang "buf = append(pad[n:m], input...)" was overwriting the pad because that pad slice had ample capacity. Yes, subtle. But after losing patience and fixing that line myself, I can only imagine that the model's feelings must have been hurt because it eventually rewrote that section of code during a later gratuitous refactor.

While at first I began with Devin (Sonnet 3.7), I soon moved to ChatGPT o3-mini-high and kept going back and forth between 3.7 Sonnet directly in Claude's UI, through Claude Code, and a bit of Gemini Advanced 2.5 Pro. 

Grand conclusion? It was far, far too much work to rely upon the AI's to bring this project to completion. With the simplicity of the architecture and code, and (by design) nothing 'hard' such as crypto, it could have been written in an evening. But it did a nice job at paving the overall structure from my description. And so had this not been a test, I'd probably ask them to implement the framework and then I'd dive in and quickly finish it. Nonetheless, great potential.

## Key Features

- **Threshold Security:**  
  The data is split into N collections, where at least K collections (with 2 ≤ K ≤ N ≤ 26) are needed to reconstruct the original content. With fewer than K collections, no information is revealed.

- **Stream-Pipelined Processing:**  
  Both the encoding and decoding processes operate as fully streaming pipelines, processing the data chunk-by-chunk without needing to load the entire dataset into memory. This makes Padlock ideal for large-scale or real-time applications.

- **Information-Theoretic Security:**  
  Instead of computational cryptography, Padlock uses a one-time-pad threshold scheme based on information theory. For each input chunk:
  - For each permutation of K collections, the system:
    - Generates K-1 random pads and XORs them with the plaintext to create a ciphertext
    - Distributes the random pads and the ciphertext across the K collections in that permutation
  - Each collection contains multiple pieces from different permutations
  - When K or more collections are combined, the original data can be reconstructed
  - With fewer than K collections, no information about the original data can be recovered

- **Flexible Output Formats:**  
  Data chunks are stored as individual files in one of two formats:
  - **PNG Files:** Files are named using the pattern  
    `IMG<collectionID>_<chunkNumber>.PNG`  
    (for example, if the collection directory is "3C5", the first chunk file is named `IMG3C5_00001.PNG`).
  - **Raw Binary Files (.bin):** Files are named with the format  
    `<collectionID>_<chunkNumber>.bin`

- **User-Friendly Messaging and Error Handling:**  
  Messages intended for users (such as summaries and error notifications) are always displayed. Detailed trace and debug messages, with component-specific prefixes (like "PADLOCK:", "FILE:", etc.), appear only when the `-verbose` flag is set.

## How It Works

### Overview

1. **Encoding Process:**
   - **Archive & Compress:**  
     The input directory is archived using tar and optionally compressed using gzip.
   - **Chunking:**  
     The compressed stream is divided into chunks of a specified maximum size.
   - **Threshold Encryption:**  
     For each chunk, the system:
     - Generates random one-time pads for each permutation of K collections
     - XORs the input data with these pads to create ciphertexts
     - Distributes the data across collections according to combinatorial mathematics
   - **Collection Organization:**  
     Collections can be stored as directories or as ZIP archives. Each collection is named with a pattern that includes the required number (K), a collection letter, and the total number of copies (N) - for example, "3A5" for the first collection in a 3-of-5 scheme.

2. **Decoding Process:**
   - **Collection Discovery:**  
     The available collection directories or ZIP files are identified. ZIP files are automatically extracted to a temporary directory for processing. The collection names (containing the required copies and total copies) are parsed to extract important parameters.
   - **Permutation Selection:**  
     The system determines which permutation to use based on the available collections. If fewer than K collections are present, an error is reported since reconstruction is mathematically impossible.
   - **Data Reconstruction:**  
     For each chunk, the appropriate permutation is used to combine pieces from K collections. The XOR operation reconstructs the original data from the distributed pieces.
   - **Extraction:**  
     The reassembled data is decompressed (if needed) and untarred to rebuild the original directory structure and files.

## Security

- **Perfect Secrecy:**  
  As long as a new one-time pad is generated securely for each chunk and is never reused, the encryption provides information-theoretic (perfect) secrecy.

- **Threshold Assurance:**  
  The design guarantees that without access to at least the required number K of collections, no useful information about the original data is revealed, regardless of the computational power available to an attacker.

- **Defense in Depth:**
  The random number generation system combines multiple independent sources of entropy to ensure high-quality randomness even if some sources are compromised.

### Security Analysis

#### Random Number Generation

Padlock implements a robust defense-in-depth approach to random number generation, which is critical for one-time pad security:

1. **Multi-Source RNG Architecture**
   - `MultiRNG` combines five independent random sources through XOR operations
   - Security depends only on the strongest uncompromised source
   - Even if multiple sources are compromised, data remains secure as long as at least one source remains uncompromised
   - Implementation includes:
     - `CryptoRand`: OS entropy pool (primary source)
     - `MathRand`: Securely seeded PRNG
     - `ChaCha20Rand`: Stream cipher with random key/nonce
     - `PCG64Rand`: High-quality statistical PRNG
     - `MT19937Rand`: Mersenne Twister with secure seed

2. **Randomness Quality Validation**
   - Comprehensive test suite validates statistical properties:
     - Frequency testing of bit distribution
     - Runs test for sequential patterns
     - Byte distribution uniformity verification
     - Shannon entropy measurement
     - Autocorrelation testing
     - Chi-square testing
   - All RNG providers use mutex locks to ensure thread safety
   - Detailed error handling prevents the use of low-quality randomness

#### K-of-N Implementation

Padlock uses a mathematical approach to K-of-N threshold security:

1. **Combinatorial Design**
   - `UniqueSortedCombinations` function generates all possible combinations of K elements from N elements
   - Each collection participates in multiple permutations
   - For each input chunk, K-1 random pads are generated
   - XOR operations distribute data across collections so any K can reconstruct the original

2. **Information-Theoretic Security**
   - With fewer than K collections, no information about the original data is revealed
   - The system provides perfect secrecy under the one-time pad model
   - Security relies on mathematical properties rather than computational hardness assumptions
   - Each collection appears completely random when viewed in isolation

#### One-Time Pad Generation and Usage

1. **Pad Generation**
   - Each chunk generates unique random pads for every permutation
   - Pad sizes match the input data exactly
   - Pads are never reused across chunks or collections
   - The `encodeOneChunk` function handles the core cryptographic operations

2. **XOR-Based Cryptography**
   - Simple XOR operations provide mathematically provable security
   - Implementation is straightforward and auditable
   - Avoids complex cryptographic primitives that could introduce vulnerabilities
   - The approach is quantum-resistant by design

#### Data Formats and Error Handling

1. **Storage Formats**
   - Binary (.bin) format for efficiency
   - PNG (.PNG) format for steganographic storage with CRC validation
   - PNG implementation includes data integrity checks via CRC32

2. **Error Detection**
   - Chunk headers contain collection names and sizes for verification
   - Collection naming convention provides self-verification
   - Format-specific integrity checks during decoding
   - Detailed error reporting for troubleshooting

#### Handling Incorrect or Corrupted Data

1. **Collection Verification**
   - System verifies collection names, required copies, and total copies
   - Mismatched parameters trigger explicit errors during decoding
   - Collections can be provided in any order during decoding

2. **Corruption Handling**
   - PNG format includes CRC32 validation to detect modifications
   - If fewer than K collections are provided, decoding mathematically fails
   - If collections are modified or corrupted:
     - Header or CRC checks fail, producing errors
     - Successful decoding with corrupted data produces garbage output that's indistinguishable from random data

#### Security Boundaries

1. **Limitations**
   - Security depends entirely on the quality of random number generation
   - Physical security of collections becomes the primary concern
   - No verification of original data integrity beyond successful reconstruction

2. **Threat Model Considerations**
   - Designed to protect against computational threats including quantum computers
   - Does not protect against insider threats with access to K or more collections
   - No protection against side-channel attacks during encoding/decoding operations

This implementation achieves information-theoretic security through a clean, auditable design that relies on well-understood mathematical principles rather than complex cryptographic primitives.

### Mathematical Foundations

#### Combinatorial Security Architecture

The K-of-N threshold scheme is built on rigorous combinatorial mathematics:

1. **Combinatorial Distribution**
   - For N collections where any K are needed, there are C(N,K) = N!/(K!(N-K)!) possible combinations
   - Each collection participates in exactly C(N-1,K-1) different permutations
   - With N=5, K=3, there are 10 unique permutations, and each collection appears in 6 permutations
   - This mathematical structure guarantees that any K collections contain at least one complete permutation

2. **XOR Properties Leveraged**
   - XOR is commutative: A ⊕ B = B ⊕ A
   - XOR is associative: (A ⊕ B) ⊕ C = A ⊕ (B ⊕ C)
   - XOR with the same value twice cancels out: A ⊕ B ⊕ B = A
   - XOR with random data produces random data: If B is truly random, then A ⊕ B is indistinguishable from random

3. **Perfect Reconstruction Properties**
   - For a permutation involving K collections (e.g., ABC):
     - Collection A stores random pad P_A
     - Collection B stores random pad P_B
     - Collection C stores C_data = D ⊕ P_A ⊕ P_B (where D is original data)
   - During decoding: P_A ⊕ P_B ⊕ C_data = P_A ⊕ P_B ⊕ (D ⊕ P_A ⊕ P_B) = D
   - XOR operations perfectly cancel out, leaving only the original data

#### Information-Theoretic Security Analysis

1. **Mathematical Proof of Threshold Properties**
   - With K-1 or fewer collections, the system of equations is underdetermined
   - For each missing piece, there are 2^n possible values (for n-bit data), all equally likely
   - This creates perfect statistical independence between available and missing pieces
   - The proof follows Claude Shannon's original work on information theory and perfect secrecy

2. **Statistical Independence**
   - Each collection in isolation appears completely random
   - No correlation exists between collections when viewed separately
   - The XOR of random data with any fixed data produces statistically random output
   - This guarantees that partial collection sets reveal zero information about the original data

#### Deep Algorithm Analysis

1. **Encoding Process Mechanics**
   ```
   For each chunk of data D:
     For each permutation P of K collections (e.g., ABC):
       Generate K-1 random pads R_1, R_2, ..., R_(K-1)
       Compute ciphertext C = D ⊕ R_1 ⊕ R_2 ⊕ ... ⊕ R_(K-1)
       Distribute D, R_1, R_2, ..., R_(K-1) across the K collections
   ```

2. **Permutation Generation Process**
   - Uses recursive backtracking to generate all K-sized combinations from N elements
   - Creates a deterministic mapping between collections and permutations
   - Ensures each collection has precisely the correct pieces for reconstruction
   - Runtime complexity is O(C(N,K)), which is polynomial for fixed K

3. **Chunking Security Benefits**
   - Enables efficient streaming processing of arbitrary-sized inputs
   - Provides natural boundaries for error containment
   - Ensures independence between chunks (compromise of one doesn't affect others)
   - Allows for piece-wise verification during reconstruction

The mathematical elegance of this system lies in its perfect balance between redundancy and security. With exactly K-1 collections, an attacker gains absolutely zero information about the data - not just computational difficulty, but mathematical impossibility. This property holds regardless of computing power, including theoretical quantum computers, making it a future-proof security approach for protecting critical data.

## Installation and Usage

### Requirements

- Go (version 1.23 or later is recommended)
- A standard Go build environment

### Building Padlock

To build the utility, run the following command in your terminal. (Simply copy and paste the command as-is.)

```bash
go build -o padlock cmd/padlock/main.go
```

### Command-Line Usage

- **Encode:**

  padlock encode <inputDir> <outputDir> -copies 5 -required 3 -format png -chunk 2097152 [-clear] [-verbose] [-zip]

  - `<inputDir>`: Directory containing the data to be archived and encoded.
  - `<outputDir>`: Destination directory for the generated collection subdirectories.
  - `-copies`: Number of collections to create (must be between 2 and 26).
  - `-required`: Minimum number of collections required for reconstruction.
  - `-format`: Output format, either "bin" or "png".
  - `-chunk`: Maximum chunk size in bytes.
  - `-clear`: (Optional) Clears the output directory before encoding.
  - `-verbose`: (Optional) Enables detailed trace/debug messages.
  - `-zip`: (Optional) Creates ZIP archives for each collection instead of directories.

- **Decode:**

  padlock decode <inputDir> <outputDir> [-clear] [-verbose]

  - `<inputDir>`: Root directory containing the collection subdirectories or ZIP files.
  - `<outputDir>`: Destination directory where the original data will be restored.
  - `-clear`: (Optional) Clears the output directory before decoding.
  - `-verbose`: (Optional) Enables detailed trace/debug messages.

**Important:**  
Do not place the output directory within the input directory to avoid recursive processing. Also, ensure that the number of available collections meets or exceeds the required threshold; otherwise, an error will be displayed.

## Implementation Details

- **Source File Organization:**
  - **cmd/padlock/main.go:** The command-line interface entry point.
  - **pkg/padlock/padlock.go:** Coordinates the encoding and decoding processes, integrating the various components.
  - **pkg/file/:** Contains modules for file and directory operations:
    - **format.go:** Implementations for working with different file formats (BIN and PNG).
    - **directory.go:** Directory validation and management.
    - **zip.go:** ZIP file creation and extraction.
    - **collection.go:** Collection directory operations.
    - **serialize.go:** Directory serialization/deserialization to/from tar streams.
    - **compress.go:** Stream compression/decompression using gzip.
  - **pkg/pad/pad.go:** Core implementation of the one-time pad threshold scheme.
  - **pkg/pad/rng.go:** Provides secure random number generation by combining multiple entropy sources.
  - **pkg/trace/trace.go:** Context-based logging system for debug and trace information.

## Disclaimer

Padlock is a demonstration of a secure, threshold-based method for splitting and encrypting data using a one-time pad and XOR operations without relying on additional cryptographic algorithms. Users must ensure that one-time pads are never reused and that configuration parameters are correctly set to achieve the intended level of security.

## License

MIT License
// This file contains the core random number generation functionality
// for the padlock system.

package pad

import (
	"context"
	"fmt"
	"strings"
	"sync"

	"github.com/rayozzie/padlock/pkg/trace"
)

// WithQuantumEnabled is a context helper for controlling RNG behavior
func WithQuantumEnabled(ctx context.Context, enabled bool) context.Context {
	return ctx 
}

// IsQuantumEnabled checks if a specific RNG mode is enabled
func IsQuantumEnabled(ctx context.Context) bool {
	return false
}

// RNG defines the core interface for all random number generators in the padlock system.
//
// This interface abstracts the generation of random bytes, allowing different
// implementations to be used interchangeably. The quality of randomness from
// implementations of this interface directly impacts the security of the entire
// one-time pad system.
//
// All implementations must:
// - Provide cryptographically secure randomness suitable for one-time pads
// - Ensure generated bytes are unpredictable even to sophisticated attackers
// - Generate non-repeating sequences across multiple calls
// - Return errors rather than providing low-quality randomness
// - Use the context for logging and potential cancellation
//
// Security note: One-time pad encryption is only as secure as its random number
// generator. If the RNG is compromised, the entire security model fails.
type RNG interface {
	// Name returns the name of the RNG implementation.
	Name() string
	// Read fills p with random bytes and returns the number of bytes written.
	// The context allows for logging, cancellation, and propagation of request-scoped values.
	// The returned error is non-nil only if the generator fails to provide randomness.
	Read(ctx context.Context, p []byte) (err error)
}

// MultiRNG provides enhanced security through entropy mixing from multiple sources.
//
// This implementation combines the output of multiple independent random number
// generators using the XOR operation. This design ensures that the final output
// is at least as secure as the strongest individual source, providing robust
// defense in depth against various failure modes.
//
// Security properties:
// - Security depends only on the strongest available source
// - Compromising all but one source still leaves the system secure
// - XOR mixing preserves the statistical properties of the best source
// - Protected against concurrent access with internal locking
// - Continues to function even if some sources fail (with error propagation)
//
// Cryptographic principle:
// If R = R₁ ⊕ R₂ ⊕ ... ⊕ Rₙ, where R represents random bytes and ⊕ is XOR,
// then an attacker must compromise ALL sources to predict R. This is because
// even one truly random source Rₓ makes the final result R unpredictable.
//
// Implementation details:
// - Reads from each source independently and completely
// - Combines all outputs through byte-by-byte XOR operations
// - Propagates errors if any source fails to provide randomness
// - Provides detailed logging with context awareness
//
// Usage context:
// This is the recommended RNG implementation for production use,
// obtained through the NewDefaultRand() function.
type MultiRNG struct {
	// Sources is a slice of RNG implementations to combine
	Sources []RNG
	// lock protects against concurrent access
	lock sync.Mutex
}

// Name
func (m *MultiRNG) Name() string {
	return "multi"
}

// Read implements the RNG interface by combining multiple random sources.
// It XORs the output of all sources to produce the final random bytes.
func (m *MultiRNG) Read(ctx context.Context, p []byte) error {
	log := trace.FromContext(ctx).WithPrefix("MULTI-RNG")

	m.lock.Lock()
	defer m.lock.Unlock()

	// Initialize accumulator
	acc := make([]byte, len(p))

	// Read from each source and XOR outputs
	sourceNames := []string{}
	for _, s := range m.Sources {
		tmp := make([]byte, len(p))

		// Determine source type for better logging
		sourceType := s.Name()
		sourceNames = append(sourceNames, sourceType)

		// If any source fails, log and propagate the error
		err := s.Read(ctx, tmp)
		if err != nil {
			log.Error(fmt.Errorf("%s random source failed: %w", sourceType, err))
			return fmt.Errorf("%s random source failed: %w", sourceType, err)
		}

		// XOR this source's output into the accumulator
		for j := 0; j < len(p); j++ {
			acc[j] ^= tmp[j]
		}
	}

	// Ensure we had at least one successful source
	if len(sourceNames) == 0 {
		return fmt.Errorf("no random sources were able to provide entropy")
	}

	// Copy final result to output buffer
	copy(p, acc)
	log.Debugf("rng: generated %d secure random bytes from %s", len(p), strings.Join(sourceNames, "+"))
	return nil
}

// NewDefaultRand creates the recommended production-ready random number generator.
//
// This factory function returns a multi-source RNG that combines several independent
// sources of randomness for maximum security and resilience against various
// failure modes. It implements defense in depth by ensuring that even if some
// randomness sources are compromised, the overall security remains intact.
//
// Security Architecture:
// The random number generation system is designed with a defense-in-depth approach:
//   - Multiple independent sources provide entropy from different algorithms
//   - Each source is independently secured with cryptographically secure seeds
//   - XOR mixing ensures that the final output is as secure as the strongest source
//   - No single point of failure exists in the randomness generation
//   - The system is resistant to both classical and quantum cryptanalysis
//
// Current implementation includes:
// 1. A cryptographically secure RNG from crypto/rand (OS-level entropy source)
//   - Uses the operating system's entropy pool (/dev/urandom or CryptGenRandom)
//   - Considered the primary and most secure source
//
// 2. A pseudo-random generator securely seeded from crypto/rand
//   - math/rand PRNG with a high-entropy seed from the OS entropy source
//   - Provides computational efficiency while maintaining security
//
// 3. ChaCha20 stream cipher with random key and nonce
//   - Modern, high-performance cryptographic algorithm
//   - Resistant to known cryptanalytic attacks
//   - Different security properties from the other sources
//
// 4. PCG64 PRNG with secure seed
//   - High-quality, statistically robust pseudo-random number generator
//   - Addresses potential weaknesses in simpler PRNGs
//   - Provides excellent statistical properties with high period
//
// 5. Mersenne Twister PRNG with secure seed
//   - Well-studied PRNG with extremely long period
//   - Provides additional diversity in the randomness sources
//
// Security properties:
// - Information-theoretic security (assuming at least one good source)
// - Resilience against implementation vulnerabilities in any single source
// - Protection against entropy depletion or source failure
// - Defense against both classical and quantum cryptanalysis
// - Multiple independent entropy sources for maximum security
// - Catastrophic failure requires compromising ALL entropy sources
//
// Usage recommendation:
//   - This function should be used to obtain an RNG for all production systems
//   - The returned RNG should be reused throughout the application's lifetime
//   - Callers should monitor returned errors which indicate entropy issues
//   - For absolute security, use air-gapped systems
//
// Example usage:
//
//	ctx := context.Background()
//	rng := pad.NewDefaultRand(ctx)
//	buf := make([]byte, 32)
//	err := rng.Read(ctx, buf)
//	if err != nil {
//	    // Handle error - this is critical and should never be ignored
//	}
//	// Use buf as high-quality random data
func NewDefaultRand(ctx context.Context) RNG {
	log := trace.FromContext(ctx).WithPrefix("RNG")
	// Create basic sources
	sources := []RNG{
		NewCryptoRand(),   // Primary cryptographic source
		NewMathRand(),     // Securely seeded PRNG
		NewChaCha20Rand(), // ChaCha20 stream cipher
		NewPCG64Rand(),    // PCG64 PRNG
		NewMT19937Rand(),  // Mersenne Twister
	}

	log.Tracef("Initializing RNG with %d base entropy sources", len(sources))
	log.Tracef("MultiRNG initialized with %d entropy sources", len(sources))

	return &MultiRNG{
		Sources: sources,
	}
}

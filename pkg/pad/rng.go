// This file contains random number generation functionality for the padlock system.
// It was previously in a separate rng package but has been moved into the pad package
// due to their close alignment in the security model.

package pad

import (
	"context"
	crand "crypto/rand"
	"fmt"
	mrand "math/rand"
	"sync"

	"github.com/rayozzie/padlock/pkg/trace"
)

// RNG defines the core interface for all random number generators in the padlock system.
//
// This interface abstracts the generation of random bytes, allowing different
// implementations to be used interchangeably. The quality of randomness from
// implementations of this interface directly impacts the security of the entire
// one-time pad system.
//
// All implementations must:
// - Provide cryptographically secure randomness suitable for one-time pads
// - Ensure generated bytes are unpredictable even to sophisticated attackers
// - Generate non-repeating sequences across multiple calls
// - Return errors rather than providing low-quality randomness
// - Use the context for logging and potential cancellation
//
// Security note: One-time pad encryption is only as secure as its random number
// generator. If the RNG is compromised, the entire security model fails.
type RNG interface {
	// Read fills p with random bytes and returns the number of bytes written.
	// The context allows for logging, cancellation, and propagation of request-scoped values.
	// The returned error is non-nil only if the generator fails to provide randomness.
	Read(ctx context.Context, p []byte) (n int, err error)
}

// CryptoRNG is the primary source of randomness for the padlock system.
//
// This implementation uses Go's crypto/rand package, which interfaces with the
// operating system's cryptographically secure random number generator (CSRNG).
// On Unix-like systems, this typically means /dev/urandom or /dev/random,
// while on Windows, it uses the CryptGenRandom API.
//
// Key security properties:
// - Uses the best available system entropy source
// - Provides cryptographically secure randomness suitable for one-time pads
// - Resistant to statistical analysis and prediction attacks
// - Protected against concurrent access with internal locking
//
// Failure modes to monitor:
// - On embedded systems, may block if system entropy is depleted
// - May return errors during OS-level entropy source failures
// - Can experience performance degradation under heavy load
//
// Usage:
// This generator should typically be used as part of a MultiRNG setup
// via the NewDefaultRNG() function, which provides additional redundancy.
type CryptoRNG struct {
	// lock protects against concurrent access to the crypto RNG
	lock sync.Mutex
}

// Read implements the RNG interface by using the platform's strongest
// random number generator with context support for logging.
func (r *CryptoRNG) Read(ctx context.Context, p []byte) (int, error) {
	log := trace.FromContext(ctx).WithPrefix("CRYPTO-RNG")
	log.Debugf("Reading %d random bytes from crypto/rand", len(p))

	r.lock.Lock()
	defer r.lock.Unlock()

	n, err := crand.Read(p)
	if err != nil {
		log.Error(fmt.Errorf("crypto/rand read failed: %w", err))
		return n, fmt.Errorf("crypto/rand read failed: %w", err)
	}

	log.Debugf("Successfully read %d random bytes", n)
	return n, nil
}

// MathRNG is a secondary source of randomness for the padlock system.
//
// This implementation uses Go's math/rand package with a cryptographically
// secure seed obtained from crypto/rand. It serves as a backup source of
// randomness, providing defense in depth in case the primary source experiences
// issues.
//
// Security properties:
// - Initialized with a high-entropy seed from crypto/rand
// - Provides deterministic but unpredictable pseudorandom sequence
// - Protected against concurrent access with internal locking
// - Computationally efficient for generating large amounts of random data
//
// Security limitations:
// - Relies on a good initial seed; compromised seed reduces security
// - Not a cryptographically secure PRNG by itself
// - Output will eventually repeat (though after a very long period)
// - Should never be used as the sole source of randomness
//
// Usage context:
// This generator is included in MultiRNG via NewDefaultRNG() to provide
// additional entropy mixing and redundancy. It is never meant to be used
// standalone for security-critical operations.
type MathRNG struct {
	// src is the pseudorandom source
	src *mrand.Rand
	// lock protects against concurrent access to the math RNG
	lock sync.Mutex
}

// NewMathRNG creates a math/rand based RNG with a secure seed from crypto/rand.
func NewMathRNG() *MathRNG {
	var seed int64
	b := make([]byte, 8)
	if _, err := crand.Read(b); err == nil {
		for i := 0; i < 8; i++ {
			seed = (seed << 8) | int64(b[i])
		}
	}
	return &MathRNG{
		src: mrand.New(mrand.NewSource(seed)),
	}
}

// Read implements the RNG interface by using a pseudo-random generator
// with a cryptographically secure seed and context support for logging.
func (mr *MathRNG) Read(ctx context.Context, p []byte) (int, error) {
	log := trace.FromContext(ctx).WithPrefix("MATH-RNG")
	log.Debugf("Reading %d random bytes from math/rand", len(p))

	mr.lock.Lock()
	defer mr.lock.Unlock()

	for i := range p {
		p[i] = byte(mr.src.Intn(256))
	}

	log.Debugf("Successfully generated %d random bytes", len(p))
	return len(p), nil
}

// MultiRNG provides enhanced security through entropy mixing from multiple sources.
//
// This implementation combines the output of multiple independent random number
// generators using the XOR operation. This design ensures that the final output
// is at least as secure as the strongest individual source, providing robust
// defense in depth against various failure modes.
//
// Security properties:
// - Security depends only on the strongest available source
// - Compromising all but one source still leaves the system secure
// - XOR mixing preserves the statistical properties of the best source
// - Protected against concurrent access with internal locking
// - Continues to function even if some sources fail (with error propagation)
//
// Cryptographic principle:
// If R = R₁ ⊕ R₂ ⊕ ... ⊕ Rₙ, where R represents random bytes and ⊕ is XOR,
// then an attacker must compromise ALL sources to predict R. This is because
// even one truly random source Rₓ makes the final result R unpredictable.
//
// Implementation details:
// - Reads from each source independently and completely
// - Combines all outputs through byte-by-byte XOR operations
// - Propagates errors if any source fails to provide randomness
// - Provides detailed logging with context awareness
//
// Usage context:
// This is the recommended RNG implementation for production use,
// obtained through the NewDefaultRNG() function.
type MultiRNG struct {
	// Sources is a slice of RNG implementations to combine
	Sources []RNG
	// lock protects against concurrent access
	lock sync.Mutex
}

// Read implements the RNG interface by combining multiple random sources.
// It XORs the output of all sources to produce the final random bytes.
func (m *MultiRNG) Read(ctx context.Context, p []byte) (int, error) {
	log := trace.FromContext(ctx).WithPrefix("MULTI-RNG")
	log.Debugf("Generating %d random bytes from %d sources", len(p), len(m.Sources))

	m.lock.Lock()
	defer m.lock.Unlock()

	// Initialize accumulator
	acc := make([]byte, len(p))

	// Read from each source and XOR outputs
	for i, s := range m.Sources {
		log.Debugf("Reading from source #%d", i+1)
		tmp := make([]byte, len(p))
		offset := 0

		// Ensure we get a full buffer from each source
		for offset < len(p) {
			n, err := s.Read(ctx, tmp[offset:])
			if err != nil {
				log.Error(fmt.Errorf("random source #%d failed: %w", i+1, err))
				return 0, fmt.Errorf("random source #%d failed: %w", i+1, err)
			}
			if n == 0 {
				continue
			}
			offset += n
		}

		// XOR this source's output into the accumulator
		for j := 0; j < len(p); j++ {
			acc[j] ^= tmp[j]
		}

		log.Debugf("Successfully mixed in %d bytes from source #%d", len(p), i+1)
	}

	// Copy final result to output buffer
	copy(p, acc)
	log.Debugf("Successfully generated %d secure random bytes", len(p))
	return len(p), nil
}

// NewDefaultRNG creates the recommended production-ready random number generator.
//
// This factory function returns a multi-source RNG that combines several independent
// sources of randomness for maximum security and resilience against various
// failure modes. It implements defense in depth by ensuring that even if some
// randomness sources are compromised, the overall security remains intact.
//
// Current implementation includes:
// 1. A cryptographically secure RNG from crypto/rand (OS-level entropy source)
// 2. A pseudo-random generator securely seeded from crypto/rand
//
// Security properties:
// - Information-theoretic security (assuming at least one good source)
// - Resilience against implementation vulnerabilities in any single source
// - Protection against entropy depletion or source failure
// - Defense against both classical and quantum cryptanalysis
//
// Usage recommendation:
//   - This function should be used to obtain an RNG for all production systems
//   - The returned RNG should be reused throughout the application's lifetime
//   - Callers should monitor returned errors which indicate entropy issues
//   - For extremely security-sensitive applications, consider adding external
//     hardware RNG sources to the returned MultiRNG's Sources slice
//
// Example usage:
//
//	rng := pad.NewDefaultRNG()
//	buf := make([]byte, 32)
//	n, err := rng.Read(buf)
//	if err != nil {
//	    // Handle error - this is critical and should never be ignored
//	}
//	// Use buf[:n] as high-quality random data
func NewDefaultRNG() RNG {
	return &MultiRNG{
		Sources: []RNG{
			&CryptoRNG{},
			NewMathRNG(),
		},
	}
}

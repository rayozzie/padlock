// This file contains the core random number generation functionality
// for the padlock system.

package pad

import (
	"context"
	"fmt"
	"sync"

	"github.com/rayozzie/padlock/pkg/trace"
)

// RNG defines the core interface for all random number generators in the padlock system.
//
// This interface abstracts the generation of random bytes, allowing different
// implementations to be used interchangeably. The quality of randomness from
// implementations of this interface directly impacts the security of the entire
// one-time pad system.
//
// All implementations must:
// - Provide cryptographically secure randomness suitable for one-time pads
// - Ensure generated bytes are unpredictable even to sophisticated attackers
// - Generate non-repeating sequences across multiple calls
// - Return errors rather than providing low-quality randomness
// - Use the context for logging and potential cancellation
//
// Security note: One-time pad encryption is only as secure as its random number
// generator. If the RNG is compromised, the entire security model fails.
type RNG interface {
	// Read fills p with random bytes and returns the number of bytes written.
	// The context allows for logging, cancellation, and propagation of request-scoped values.
	// The returned error is non-nil only if the generator fails to provide randomness.
	Read(ctx context.Context, p []byte) (n int, err error)
}

// MultiRNG provides enhanced security through entropy mixing from multiple sources.
//
// This implementation combines the output of multiple independent random number
// generators using the XOR operation. This design ensures that the final output
// is at least as secure as the strongest individual source, providing robust
// defense in depth against various failure modes.
//
// Security properties:
// - Security depends only on the strongest available source
// - Compromising all but one source still leaves the system secure
// - XOR mixing preserves the statistical properties of the best source
// - Protected against concurrent access with internal locking
// - Continues to function even if some sources fail (with error propagation)
//
// Cryptographic principle:
// If R = R₁ ⊕ R₂ ⊕ ... ⊕ Rₙ, where R represents random bytes and ⊕ is XOR,
// then an attacker must compromise ALL sources to predict R. This is because
// even one truly random source Rₓ makes the final result R unpredictable.
//
// Implementation details:
// - Reads from each source independently and completely
// - Combines all outputs through byte-by-byte XOR operations
// - Propagates errors if any source fails to provide randomness
// - Provides detailed logging with context awareness
//
// Usage context:
// This is the recommended RNG implementation for production use,
// obtained through the NewDefaultRNG() function.
type MultiRNG struct {
	// Sources is a slice of RNG implementations to combine
	Sources []RNG
	// lock protects against concurrent access
	lock sync.Mutex
}

// Read implements the RNG interface by combining multiple random sources.
// It XORs the output of all sources to produce the final random bytes.
func (m *MultiRNG) Read(ctx context.Context, p []byte) (int, error) {
	log := trace.FromContext(ctx).WithPrefix("MULTI-RNG")
	log.Debugf("Generating %d random bytes from %d sources", len(p), len(m.Sources))

	m.lock.Lock()
	defer m.lock.Unlock()

	// Initialize accumulator
	acc := make([]byte, len(p))

	// Track which sources successfully contributed
	successfulSources := 0

	// Read from each source and XOR outputs
	for i, s := range m.Sources {
		log.Debugf("Reading from source #%d", i+1)
		tmp := make([]byte, len(p))
		offset := 0

		// Determine source type for better logging
		sourceType := "generic"
		if _, ok := s.(*CryptoRNG); ok {
			sourceType = "crypto"
		} else if _, ok := s.(*MathRNG); ok {
			sourceType = "math"
		} else if _, ok := s.(*QuantumRNG); ok {
			sourceType = "quantum"
		} else if _, ok := s.(*ChaCha20Rand); ok {
			sourceType = "chacha20"
		} else if _, ok := s.(*PCG64Rand); ok {
			sourceType = "pcg64"
		} else if _, ok := s.(*MT19937Rand); ok {
			sourceType = "mt19937"
		}

		// Ensure we get a full buffer from each source
		sourceSuccess := false
		for offset < len(p) {
			n, err := s.Read(ctx, tmp[offset:])

			// If any source fails, log and propagate the error
			if err != nil {
				log.Error(fmt.Errorf("%s random source failed: %w", sourceType, err))
				return 0, fmt.Errorf("%s random source failed: %w", sourceType, err)
			}

			// Skip on zero bytes read
			if n == 0 {
				continue
			}

			// Mark progress
			offset += n
			sourceSuccess = true
		}

		// Only XOR and count this source if it successfully provided data
		if sourceSuccess {
			// XOR this source's output into the accumulator
			for j := 0; j < len(p); j++ {
				acc[j] ^= tmp[j]
			}
			successfulSources++
			log.Debugf("Successfully mixed in %d bytes from %s source", len(p), sourceType)
		}
	}

	// Ensure we had at least one successful source
	if successfulSources == 0 {
		return 0, fmt.Errorf("no random sources were able to provide entropy")
	}

	// Copy final result to output buffer
	copy(p, acc)
	log.Debugf("Successfully generated %d secure random bytes from %d sources", len(p), successfulSources)
	return len(p), nil
}

// NewDefaultRNG creates the recommended production-ready random number generator.
//
// This factory function returns a multi-source RNG that combines several independent
// sources of randomness for maximum security and resilience against various
// failure modes. It implements defense in depth by ensuring that even if some
// randomness sources are compromised, the overall security remains intact.
//
// Current implementation includes:
// 1. A cryptographically secure RNG from crypto/rand (OS-level entropy source)
// 2. A pseudo-random generator securely seeded from crypto/rand
// 3. ChaCha20 stream cipher with random key and nonce
// 4. PCG64 PRNG with secure seed
// 5. Mersenne Twister PRNG with secure seed
// 6. ANU Quantum Random Numbers service (optional, enabled with -quantum-anu flag)
//
// Security properties:
// - Information-theoretic security (assuming at least one good source)
// - Resilience against implementation vulnerabilities in any single source
// - Protection against entropy depletion or source failure
// - Defense against both classical and quantum cryptanalysis
// - Multiple independent entropy sources for maximum security
//
// Usage recommendation:
//   - This function should be used to obtain an RNG for all production systems
//   - The returned RNG should be reused throughout the application's lifetime
//   - Callers should monitor returned errors which indicate entropy issues
//   - For extreme security, enable quantum RNG with -quantum-anu flag
//
// Example usage:
//
//	ctx := context.Background()
//	// Optional: Enable quantum RNG if -quantum-anu flag was specified
//	ctx = pad.WithQuantumEnabled(ctx, quantumFlagSpecified)
//
//	rng := pad.NewDefaultRNG(ctx)
//	buf := make([]byte, 32)
//	n, err := rng.Read(ctx, buf)
//	if err != nil {
//	    // Handle error - this is critical and should never be ignored
//	}
//	// Use buf[:n] as high-quality random data
func NewDefaultRNG(ctx context.Context) RNG {
	// Create basic sources
	sources := []RNG{
		&CryptoRNG{},      // Primary cryptographic source
		NewMathRNG(),      // Securely seeded PRNG
		NewChaCha20Rand(), // ChaCha20 stream cipher
		NewPCG64Rand(),    // PCG64 PRNG
		NewMT19937Rand(),  // Mersenne Twister
	}

	// Add quantum RNG only if explicitly enabled
	if IsQuantumEnabled(ctx) {
		log := trace.FromContext(ctx).WithPrefix("RNG")
		log.Infof("Using ANU Quantum Random Numbers service (https://qrng.anu.edu.au)")
		sources = append(sources, NewQuantumRNG())
	}

	return &MultiRNG{
		Sources: sources,
	}
}
